
//DynamicDirective
// Заполняет документ на основании другого документа с помощью ИНИ.
//
// Параметры:
//  ЭтаФорма - ФормаКлиентскогоПриложения - форма объекта для заполнения.
//  ДокументОснование - ДокументСсылка - ссылка на документ основание.
//  ИмяМетаданных - Строка - имя метаданных документа
//  
// Возвращаемое значение:
//   Структура - результат заполнения на основании ИНИ
//
Функция ЗаполнитьНаОснованииINI(ЭтаФорма, ДокументОснование, ИмяМетаданных) Экспорт
	
	ФормаОбъект = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").ФормаОбъект(ЭтаФорма);
	
	ПараметрыЗаполнения = ПараметрыЗаполненияНаОснованииINI(ФормаОбъект, ИмяМетаданных);
	
	ПерваяИтерация = Истина;
	
	ОснованияДляЗаполнения = ВыполнитьНаСервере(
		"Saby_ТНОбщегоНазначенияСервер.ДанныеОснованийДляЗаполненияНаОснованииINI", ДокументОснование, ПараметрыЗаполнения);
	
	Если ПараметрыЗаполнения.НаКлиенте Тогда
		ТранспортБлокли = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиент").ПолучитьФормуНаКлиенте(ИмяКлиентскогоТранспортаБлокли());
		ТранспортБлокли.ИнициироватьТранспорт();
	Иначе
		ТранспортБлокли = Неопределено;
	КонецЕсли;
	
	#Если НаСервере Тогда
		МодульФормы = МодульКодаКлиент("Saby_ТНОбщегоНазначенияСервер");
	#Иначе 	
		МодульФормы = МодульКодаКлиент("ЭтаФорма");
	#КонецЕсли
	
	Для Каждого СтруктураОснования Из ОснованияДляЗаполнения Цикл
		
		ПараметрыЗаполнения.ini_name             = СтруктураОснования.ini_name;
		ПараметрыЗаполнения.Основание            = СтруктураОснования.Основание;
		ПараметрыЗаполнения.ЭтоВыбранныйДокумент = СтруктураОснования.Основание = ДокументОснование;
		ПараметрыЗаполнения.ЭтоПервоеОснование   = ПерваяИтерация;
		ПараметрыЗаполнения.РольКонтрагента      = СтруктураОснования.РольКонтрагента;
		
		Если ПараметрыЗаполнения.НаКлиенте Тогда
			ПараметрыЗаполнения.РезультатРасчетаИНИ = МодульФормы.РезультатРасчетаINI(
				ПараметрыЗаполнения, ТранспортБлокли);
		КонецЕсли;
		
		РезультатФункции = ВыполнитьНаСервере(
			"Saby_ТНОбщегоНазначенияСервер.РезультатЗаполненияНаОснованииINI", ПараметрыЗаполнения);
		
		Если РезультатФункции.Ошибка Тогда
			Прервать;
		КонецЕсли;
		
		Если ТипЗнч(ФормаОбъект.Ссылка) = Тип("Структура") Тогда
			ПараметрыЗаполнения.Ссылка           = РезультатФункции.Ссылка;
			ФормаОбъект.Ссылка                   = ПараметрыЗаполнения.Ссылка;
			ПараметрыЗаполнения.ЗапретЗаполнения = РезультатФункции.ЗапретЗаполнения;
		КонецЕсли;
		
		ДобавитьОснованияДляЗаполнения(ПараметрыЗаполнения, ОснованияДляЗаполнения, РезультатФункции);
		
		ПерваяИтерация = Ложь;
		
	КонецЦикла;
	
	РезультатФункции.Вставить("ТекстЗаголовка", "Ошибка");
	
	#Если НаСервере Тогда
		Картинка = МодульФормы.КартинкаИнтерфейсаСервер(ЭтаФорма, "Saby_Успешно32");
	#Иначе 	
		Картинка = МодульФормы.КартинкаИнтерфейса(ЭтаФорма, "Saby_Успешно32");
	#КонецЕсли
	
	РезультатФункции.Вставить("Картинка", Картинка);
	
	ВыполнитьНаСервере("Saby_ТНОбщегоНазначенияСервер.СвернутьГруз", ФормаОбъект.Ссылка, ПараметрыЗаполнения, РезультатФункции);
	
	Если РезультатФункции.Ошибка Тогда
		 		
		#Если НаСервере Тогда
			Картинка = МодульФормы.КартинкаИнтерфейсаСервер(ЭтаФорма, "Saby_Ошибка32");
		#Иначе 	
			Картинка = МодульФормы.КартинкаИнтерфейса(ЭтаФорма, "Saby_Ошибка32");
		#КонецЕсли
		
		РезультатФункции.Картинка = Картинка;
		
	Иначе
		РезультатФункции.ТекстЗаголовка = "Выполнено";
	КонецЕсли;
	
	Возврат РезультатФункции;
	
КонецФункции

//DynamicDirective
// Расчитывает ИНИ по заданным параметрам
//
// Параметры:
//  ПараметрыЗаполнения - Структура - параметры для выполнения расчета ИНИ.
//  ТранспортБлокли - ФормаКлиентскогоПриложения - форма транспорта
//
// Возвращаемое значение:
//   Структура - результат расчета ИНИ
//
Функция РезультатРасчетаINI(ПараметрыЗаполнения, ТранспортБлокли) Экспорт
		
	РезультатФункции = Новый Структура;
	РезультатФункции.Вставить("Результат",   Новый Структура);
	РезультатФункции.Вставить("ДанныеИзИНИ", Неопределено);
	
	РезультатФункции.Результат.Вставить("ТекстЗаголовка", "");
	РезультатФункции.Результат.Вставить("ТекстСообщения", "");
	РезультатФункции.Результат.Вставить("Ошибка",         Ложь);
	РезультатФункции.Результат.Вставить("НовыеОснования", Новый Массив);
	
	Ошибка = Ложь;
	Если Не ЗначениеЗаполнено(ПараметрыЗаполнения.Основание) Тогда
		
		ТекстЗаголовка = "Ошибка параметров";
		ТекстСообщения = "Не заполнено основание расчета!";
		Ошибка = Истина;
		
	КонецЕсли;
	
	Если Ошибка Тогда 
		
		РезультатФункции.Результат.ТекстЗаголовка = ТекстЗаголовка;
		РезультатФункции.Результат.ТекстСообщения = ТекстСообщения;
		РезультатФункции.Результат.Ошибка = Истина;
		Возврат РезультатФункции;

	КонецЕсли;
	
	ConnectionId = Неопределено;
	ПараметрыЗаполнения.context_params.Свойство("ConnectionId", ConnectionId);
	
	ПараметрыВызова = Новый Соответствие();
	ПараметрыВызова.Вставить("params",          ПараметрыЗаполнения.context_params);
	ПараметрыВызова.Вставить("commands_result", Новый Массив);
	ПараметрыВызова.Вставить("endpoint",        "");
	ПараметрыВызова.Вставить("operation_uuid",  СокрЛП(Новый УникальныйИдентификатор));
	ПараметрыВызова.Вставить("algorithm",       ПараметрыЗаполнения.ini_name);
	ПараметрыВызова.Вставить("connection_uuid", ConnectionId);
	ПараметрыВызова.Вставить("ref",             ПараметрыЗаполнения.Основание);
	
	Результат = ТранспортБлокли.API_BLOCKLY_RUN(ПараметрыВызова);
	
	Если Результат.status <> "complete" Тогда
		РезультатФункции.Результат.ТекстЗаголовка = "Ошибка расчета";
		РезультатФункции.Результат.ТекстСообщения = Результат.data.message;
		РезультатФункции.Результат.Ошибка = Истина;
		Возврат РезультатФункции;
	КонецЕсли;
	
	ДанныеИзИНИ = Результат.data;
	
	ВосстановитьИерархию(ДанныеИзИНИ);
		
	РезультатФункции.ДанныеИзИНИ = ДанныеИзИНИ;
		
	Возврат РезультатФункции;
	
КонецФункции

//DynamicDirective

Функция ПараметрыЗаполненияНаОснованииINI(Объект = Неопределено, ИмяМетаданных = "")
	
	ПараметрыКонтекста = ВыполнитьНаСервере("Saby_Core.ПроверитьНаличиеПараметровПодключения", Неопределено);
	
	ШаблонИмениИНИ = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").ШаблонИмениINI(ИмяМетаданных);
	
	РезультатФункции = Новый Структура;
	РезультатФункции.Вставить("ini_name",                  "");
	РезультатФункции.Вставить("ИмяМетаданных",             ИмяМетаданных);
	РезультатФункции.Вставить("Основание",                 Неопределено);
	РезультатФункции.Вставить("ЭтоВыбранныйДокумент",      Ложь);
	РезультатФункции.Вставить("ЭтоПервоеОснование",        Ложь);
	РезультатФункции.Вставить("ТранспортБлокли",           Неопределено);
	РезультатФункции.Вставить("context_params",            ПараметрыКонтекста);
	РезультатФункции.Вставить("РольКонтрагента",           ЗначениеМетаданных("Saby_РолиКонтрагентов.ПустаяСсылка"));
	РезультатФункции.Вставить("ЗапретЗаполнения",          Новый Соответствие);
	РезультатФункции.Вставить("НоменклатураГруза",         Новый Соответствие);
	РезультатФункции.Вставить("КлючСтроки",                МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").СтруктураКлючСтроки());
	РезультатФункции.Вставить("СопроводительныеДокументы", Новый Массив);
	РезультатФункции.Вставить("ШаблонИмениИНИ",            ШаблонИмениИНИ);
	РезультатФункции.Вставить("РезультатРасчетаИНИ",       Неопределено);
	Если Объект <> Неопределено Тогда
		РезультатФункции.Вставить("Ссылка",                Объект.Ссылка);
		РезультатФункции.Вставить("НаКлиенте",             ТипЗнч(Объект.Ссылка) = Тип("Структура"));
	КонецЕсли;
		
	Возврат РезультатФункции;
	
КонецФункции

//DynamicDirective

Процедура ДобавитьОснованияДляЗаполнения(ПараметрыЗаполнения, ОснованияДляЗаполнения, РезультатФункции)
	
	ИмяИНИ = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").СтрШаблонЭПД(
		ПараметрыЗаполнения.ШаблонИмениИНИ, "ДанныеКонтрагентаОрганизации");
	
	Если Не РезультатФункции.Свойство("НовыеОснования") Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПоиска = Новый Структура("РольКонтрагента");
	
	Для Каждого НовоеОснование Из РезультатФункции.НовыеОснования Цикл
		
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, НовоеОснование);
		НайденныеСтроки = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").НайтиСтрокиУниверсально(
			ОснованияДляЗаполнения, СтруктураПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтруктураОснования = НайденныеСтроки[0];
		Иначе
			СтруктураОснования = МодульКодаКлиент("Saby_ТНОбщегоНазначенияСервер").СтруктураОснования("", "", "");
			ОснованияДляЗаполнения.Добавить(СтруктураОснования);
		КонецЕсли;
		
		СтруктураОснования.Основание       = НовоеОснование.Основание;
		СтруктураОснования.ini_name        = ИмяИНИ;
		СтруктураОснования.РольКонтрагента = НовоеОснование.РольКонтрагента;
		
	КонецЦикла;
	
КонецПроцедуры

//DynamicDirective

Функция ИмяКлиентскогоТранспортаБлокли()
	
	Возврат "BlocklyExecutor";
	
КонецФункции

#Область ВосстановлениеИерархии

//DynamicDirective
// Создает иерархию структуры по ключам написанным через разделитель 
//
// Параметры:
//  ИсходныеДанные - Структура - плоская структура с ключами содержащими разделитель
//  Разделитель    - Строка - разделитель уровней вложенности иерархии
//
Процедура ВосстановитьИерархию(ИсходныеДанные, Разделитель = ".") Экспорт
	
	Если ТипЗнч(ИсходныеДанные) = Тип("Структура") Или ТипЗнч(ИсходныеДанные) = Тип("Соответствие") Тогда
		Для Каждого КлючЗначение Из ИсходныеДанные Цикл
			Значение = ИсходныеДанные[КлючЗначение.Ключ];
			УровниИерархии = МодульКодаКлиент("Saby_ТНОбщегоНазначенияКлиентСервер").СтрРазделитьЭПД(КлючЗначение.Ключ, Разделитель);
			ПоместитьНаУровеньИерархии(ИсходныеДанные, Значение, УровниИерархии, КлючЗначение.Ключ);
			ВосстановитьИерархию(Значение, Разделитель);
		КонецЦикла;
	ИначеЕсли ТипЗнч(ИсходныеДанные) = Тип("Массив") Тогда
		Для Каждого Значение Из ИсходныеДанные Цикл
			ВосстановитьИерархию(Значение, Разделитель);
		КонецЦикла;
	Иначе
		Возврат;
	КонецЕсли;
	
КонецПроцедуры


//DynamicDirective
// Перемещение значения на нужный уровень иерархии в зависимости от ключа с разделителем 
//
// Параметры:
//  ИсходныеДанные - Структура - плоская структура с ключами содержащими разделитель
//  Значение       - Структура - узел структуры для построения иерархии
//  УровниИерархии - Массив    - массив кровней полученный после рзделения на уровни
//  ИсходныйКлюч   - Строка    - ключ с разделителями
//
Процедура ПоместитьНаУровеньИерархии(ИсходныеДанные, Значение, УровниИерархии, ИсходныйКлюч)
	
	Если УровниИерархии.Количество() = 1 Тогда
		Возврат;
	КонецЕсли;
	
	НовыйУровеньИерархии = ИсходныеДанные;
	ИмяПоследнегоУровня  = УровниИерархии[УровниИерархии.ВГраница()];
	
	Для Каждого ИмяУровня Из УровниИерархии Цикл
		
		Если Не УровеньИерархииСуществует(НовыйУровеньИерархии, ИмяУровня) Тогда
			ДобавитьУровеньИерархии(НовыйУровеньИерархии, ИмяУровня);
		КонецЕсли;
		
		Если ИмяУровня <> ИмяПоследнегоУровня Тогда
			НовыйУровеньИерархии = НовыйУровеньИерархии[ИмяУровня];
		КонецЕсли;
		
	КонецЦикла;
	
	НовыйУровеньИерархии.Вставить(ИмяУровня, Значение);
	ИсходныеДанные.Удалить(ИсходныйКлюч);
	
КонецПроцедуры

//DynamicDirective
// Проверка существования/отсутствия уровня иерархии в узле 
//
// Параметры:
//  ТекущийУровеньИерархии - Структура - узел для проверки уровня
//  ИмяУровня - Строка - имя проверяемого уровня
//
// Возвращаемое значение:
//   Булево - Истина, если уровень существует
//
Функция УровеньИерархииСуществует(ТекущийУровеньИерархии, ИмяУровня)
	
	Если ТипЗнч(ТекущийУровеньИерархии) = Тип("Соответствие") Тогда
		Возврат ТекущийУровеньИерархии[ИмяУровня] <> Неопределено;
	ИначеЕсли ТипЗнч(ТекущийУровеньИерархии) = Тип("Структура") Тогда
		Возврат ТекущийУровеньИерархии.Свойство(ИмяУровня);
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

//DynamicDirective
// Добавление нового уровня иерархии в узел 
//
// Параметры:
//  ТекущийУровеньИерархии - Структура - узел для добавления уровня
//  ИмяУровня - Строка - имя нового уровня
//
Процедура ДобавитьУровеньИерархии(ТекущийУровеньИерархии, ИмяУровня)
	
	Если ТипЗнч(ТекущийУровеньИерархии) = Тип("Соответствие") Тогда
		ТекущийУровеньИерархии.Вставить(ИмяУровня, Новый Соответствие);
	ИначеЕсли ТипЗнч(ТекущийУровеньИерархии) = Тип("Структура") Тогда
		ТекущийУровеньИерархии.Вставить(ИмяУровня, Новый Структура);
	Иначе
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти // ВосстановлениеИерархии

